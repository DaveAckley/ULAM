## -*- mode:ulam -*-
#=t41432_test_compiler_elementtemplatewithinheritedclassparameterquarktemplateandancestorwdefaultvalue_error
#!
./Crackle.ulam:5:48: ERROR: Not ready constant for type: Unsigned(32), used with constant symbol name 'cTrigger'.
./Crackle.ulam:5:32: ERROR: Constant value expression for: trig, is not ready, still hazy.
./R.ulam:15:5: ERROR: Incomplete descriptor for type: Crackle(0xf00d,trig) (UTI 35).
./R.ulam:15:5: ERROR: Incomplete Variable Decl for type: Crackle(0xf00d,trig), used with variable symbol name 'crackle'.
./R.ulam:16:21: ERROR: Incomplete identifier for type: Crackle(0xf00d,trig), used with list symbol name 'crackle'.
./R.ulam:16:29: ERROR: Member selected is incomplete class: unresolved, check and label fails this time around.
./R.ulam:16:5: ERROR: Initial value expression for: ans2, initialization is not ready.
Unrecoverable Program Type Label FAILURE.
##
## see t41431. cannot use constant as default that is set to a local constant, why?? BUG.
##
#>R.ulam
  ulam 5;
element R {
  Int test()
  {
    System s;
    Pop(0xfeed, 7, 3, 1) pop;

    Unsigned ans = pop.behaving();
    s.print(ans);
    s.assert(ans==3u);

    s.assert(pop.samely());
    s.assert(!pop.badly());

    Crackle(0xf00d) crackle;
    Unsigned ans2 = crackle.behaving();
    s.print(ans2);
    s.assert(ans2==4u);
    return 0;
  }
}

#:Crackle.ulam
  ulam 5;
local constant Unsigned(5) cTag = 3;
local constant Unary(5) cProg = 4;
local constant Unsigned cLevel = 2;
transient Crackle(Bits specId, Unsigned trig = cTrigger) : Pop(specId,cTag,cProg,cLevel)
{
  constant Unsigned cTrigger = local.cLevel; //too bad can't use as default value!!
  Bits mId = specId;
}

#:Pop.ulam
  ulam 5;
quark Pop(Bits speciesID, Unsigned(5) mytag, Unary(5) myProgress, Unsigned triggerlevel) {
  typedef Foo(myProgress,mytag,false) MyFoo; //typedef
  MyFoo mFoo; //dm

  Unsigned behaving() {
    return mFoo.func();
  }

  Bool samely() {
    Foo(myProgress,mytag,false) foo; //local
    return mFoo.func() == foo.func();
  }

  Bool badly() {
    MyFoo foo;
    return foo.z == mFoo.mZar.z;
  }

}

#:Foo.ulam
  ulam 5;
local constant Bool cTrue = true;
quark Foo(Unary(5) x, Unsigned(4) y, Bool z) : Zar(x, y, z) {
  Zar(x,y,cTrue) mZar;
}

#:Zar.ulam
  ulam 5;
quark Zar(Unary(5) x, Unsigned(4) y, Bool z) { //same param names not the problem!
  Unsigned func() { return x; }
}

#:System.ulam
  ulam 1;
quark System {
Void print(Unsigned arg) native;
Void print(Int arg) native;
Void print(Int(4) arg) native;
Void print(Int(3) arg) native;
Void print(Unary(3) arg) native;
Void print(Bool(3) arg) native;
Void assert(Bool b) native;
}
#.
